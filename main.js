/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WordCloudPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  minFontSize: 12,
  maxFontSize: 48,
  colorPalette: ["#0066cc", "#cc6600", "#cc0066", "#6600cc", "#00cc66"],
  separator: ",",
  spacing: "normal",
  autoFontSize: true,
  autoSpacing: true,
  casing: "as-is"
};
var SPACING_CONFIG = {
  "compact": { padding: 3, margin: 5, startRadius: 1, spiralStep: 1.5 },
  "normal": { padding: 12, margin: 12, startRadius: 5, spiralStep: 4 },
  "comfortable": { padding: 22, margin: 18, startRadius: 12, spiralStep: 7 },
  "loose": { padding: 35, margin: 25, startRadius: 20, spiralStep: 10 }
};
function getAutoSpacing(wordCount, isMobile = false) {
  if (isMobile) {
    if (wordCount <= 10) {
      return SPACING_CONFIG["comfortable"];
    } else if (wordCount <= 20) {
      return SPACING_CONFIG["normal"];
    } else {
      return SPACING_CONFIG["compact"];
    }
  }
  if (wordCount <= 10) {
    return SPACING_CONFIG["loose"];
  } else if (wordCount <= 20) {
    return SPACING_CONFIG["comfortable"];
  } else if (wordCount <= 40) {
    return SPACING_CONFIG["normal"];
  } else {
    return SPACING_CONFIG["compact"];
  }
}
function applyCasing(text, casing) {
  switch (casing) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "title-case":
      const words = text.toLowerCase().split(" ");
      if (words.length === 1) {
        return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
      } else {
        const smallWords = ["a", "an", "and", "as", "at", "but", "by", "for", "in", "of", "on", "or", "the", "to", "with"];
        return words.map((word, index) => {
          if (index === 0 || index === words.length - 1 || !smallWords.includes(word)) {
            return word.charAt(0).toUpperCase() + word.slice(1);
          }
          return word;
        }).join(" ");
      }
    case "as-is":
    default:
      return text;
  }
}
function getAutoFontSizes(wordCount, isMobile = false) {
  if (isMobile) {
    if (wordCount <= 10) {
      return { min: 14, max: 32 };
    } else if (wordCount <= 20) {
      return { min: 12, max: 26 };
    } else if (wordCount <= 40) {
      return { min: 10, max: 20 };
    } else if (wordCount <= 70) {
      return { min: 9, max: 16 };
    } else {
      return { min: 8, max: 14 };
    }
  }
  if (wordCount <= 10) {
    return { min: 20, max: 56 };
  } else if (wordCount <= 20) {
    return { min: 16, max: 40 };
  } else if (wordCount <= 40) {
    return { min: 14, max: 32 };
  } else if (wordCount <= 70) {
    return { min: 12, max: 28 };
  } else {
    return { min: 10, max: 22 };
  }
}
var WordCloudPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("cloud", "Generate Word Cloud", (evt) => {
      new WordCloudModal(this.app, this).open();
    });
    this.addCommand({
      id: "insert-word-cloud",
      name: "Insert Word Cloud",
      editorCallback: (editor, view) => {
        new WordCloudModal(this.app, this, editor).open();
      }
    });
    this.registerMarkdownCodeBlockProcessor("wordcloud", (source, el, ctx) => {
      this.renderWordCloud(source, el);
    });
    this.addSettingTab(new WordCloudSettingTab(this.app, this));
  }
  renderWordCloud(source, container) {
    container.empty();
    container.addClass("word-cloud-container");
    const separator = this.settings.separator || ",";
    const rawWords = source.split(separator).map((w) => w.trim()).filter((w) => w.length > 0);
    const words = rawWords.map((word) => applyCasing(word, this.settings.casing));
    if (words.length === 0) {
      container.createEl("p", { text: `No words provided. Add ${separator}-separated words.` });
      return;
    }
    const colors = this.settings.colorPalette.length > 0 ? this.settings.colorPalette : DEFAULT_SETTINGS.colorPalette;
    const getContainerWidth = () => {
      if (container.offsetWidth > 0) {
        return container.offsetWidth;
      }
      if (typeof window !== "undefined") {
        return Math.min(window.innerWidth - 40, 700);
      }
      return 700;
    };
    const containerWidth = getContainerWidth();
    const isMobile = containerWidth < 500;
    let minFontSize;
    let maxFontSize;
    if (this.settings.autoFontSize) {
      const autoSizes = getAutoFontSizes(words.length, isMobile);
      minFontSize = autoSizes.min;
      maxFontSize = autoSizes.max;
    } else {
      minFontSize = this.settings.minFontSize;
      maxFontSize = this.settings.maxFontSize;
    }
    let spacingConfig;
    if (this.settings.autoSpacing) {
      spacingConfig = getAutoSpacing(words.length, isMobile);
    } else {
      const currentSpacing = this.settings.spacing || "normal";
      spacingConfig = SPACING_CONFIG[currentSpacing];
    }
    const containerHeight = isMobile ? 400 : 500;
    container.style.height = containerHeight + "px";
    container.style.position = "relative";
    const renderWords = (centeredWord = null) => {
      container.empty();
      let shuffledWords;
      if (centeredWord) {
        const otherWords = words.filter((w) => w !== centeredWord);
        shuffledWords = [centeredWord, ...otherWords.sort(() => Math.random() - 0.5)];
      } else {
        shuffledWords = [...words].sort(() => Math.random() - 0.5);
      }
      const placedElements = [];
      const checkOverlap = (rect1, rect2) => {
        const padding = spacingConfig.padding;
        let w1 = rect1.width;
        let h1 = rect1.height;
        if (Math.abs(rect1.rotation) === 90) {
          [w1, h1] = [h1, w1];
        }
        let w2 = rect2.width;
        let h2 = rect2.height;
        if (Math.abs(rect2.rotation) === 90) {
          [w2, h2] = [h2, w2];
        }
        const left1 = rect1.centerX - w1 / 2 - padding;
        const right1 = rect1.centerX + w1 / 2 + padding;
        const top1 = rect1.centerY - h1 / 2 - padding;
        const bottom1 = rect1.centerY + h1 / 2 + padding;
        const left2 = rect2.centerX - w2 / 2 - padding;
        const right2 = rect2.centerX + w2 / 2 + padding;
        const top2 = rect2.centerY - h2 / 2 - padding;
        const bottom2 = rect2.centerY + h2 / 2 + padding;
        return !(right1 < left2 || left1 > right2 || bottom1 < top2 || top1 > bottom2);
      };
      const tempElements = [];
      const canvas = document.createElement("canvas");
      let ctx = null;
      try {
        ctx = canvas.getContext("2d");
      } catch (error) {
        console.error("Canvas context error:", error);
      }
      if (!ctx) {
        console.error("Could not get canvas context");
        shuffledWords.forEach((word) => {
          const isCentered = centeredWord === word;
          const fontSize = isCentered ? Math.floor((maxFontSize + minFontSize) / 2 + 10) : Math.floor(Math.random() * (maxFontSize - minFontSize + 1)) + minFontSize;
          const color = colors[Math.floor(Math.random() * colors.length)];
          const rotations = isCentered ? [0] : [0, 0, 0, 0, 90, -90];
          const rotation = rotations[Math.floor(Math.random() * rotations.length)];
          const width = Math.ceil(word.length * fontSize * 0.6) + 8;
          const height = fontSize + 8;
          tempElements.push({
            width,
            height,
            fontSize,
            color,
            rotation,
            word,
            isCentered
          });
        });
        requestAnimationFrame(() => {
          setTimeout(() => {
            positionWords();
          }, 50);
        });
        return;
      }
      shuffledWords.forEach((word) => {
        const isCentered = centeredWord === word;
        const fontSize = isCentered ? Math.floor((maxFontSize + minFontSize) / 2 + 10) : Math.floor(Math.random() * (maxFontSize - minFontSize + 1)) + minFontSize;
        const color = colors[Math.floor(Math.random() * colors.length)];
        const rotations = isCentered ? [0] : [0, 0, 0, 0, 90, -90];
        const rotation = rotations[Math.floor(Math.random() * rotations.length)];
        const fontFamily = container.isConnected ? getComputedStyle(container).fontFamily || "Arial, sans-serif" : "Arial, sans-serif";
        ctx.font = `bold ${fontSize}px ${fontFamily}`;
        const metrics = ctx.measureText(word);
        const width = Math.ceil(metrics.width) + 8;
        const height = fontSize + 8;
        tempElements.push({
          width,
          height,
          fontSize,
          color,
          rotation,
          word,
          isCentered
        });
      });
      requestAnimationFrame(() => {
        setTimeout(() => {
          positionWords();
        }, 50);
      });
      const positionWords = () => {
        if (!centeredWord) {
          tempElements.sort((a, b) => b.width * b.height - a.width * a.height);
        }
        const centerX = containerWidth / 2;
        const centerY = containerHeight / 2;
        tempElements.forEach((temp) => {
          const tag = container.createEl("span");
          tag.addClass("word-cloud-word");
          tag.textContent = temp.word;
          tag.style.fontSize = temp.fontSize + "px";
          tag.style.color = temp.color;
          tag.style.position = "absolute";
          tag.style.whiteSpace = "nowrap";
          tag.style.fontWeight = "bold";
          tag.style.cursor = "pointer";
          tag.style.transition = "all 0.5s ease";
          tag.style.userSelect = "none";
          tag.style.setProperty("-webkit-tap-highlight-color", "transparent");
          tag.style.touchAction = "manipulation";
          tag.style.willChange = "transform";
          tag.style.backfaceVisibility = "hidden";
          tag.style.setProperty("-webkit-font-smoothing", "antialiased");
          tag.style.setProperty("-moz-osx-font-smoothing", "grayscale");
          const tagWidth = temp.width;
          const tagHeight = temp.height;
          const rotation = temp.rotation;
          const isCentered = temp.isCentered;
          let placed = false;
          if (isCentered) {
            const x = centerX - tagWidth / 2;
            const y = centerY - tagHeight / 2;
            tag.style.left = x + "px";
            tag.style.top = y + "px";
            tag.style.transform = `rotate(${rotation}deg) scale(1.2)`;
            tag.style.transformOrigin = "center center";
            tag.style.fontWeight = "900";
            tag.style.zIndex = "50";
            placedElements.push({
              centerX,
              centerY,
              width: tagWidth * 1.5,
              height: tagHeight * 1.5,
              rotation
            });
            placed = true;
          } else {
            let spiralRadius = 120;
            const spiralStep = spacingConfig.spiralStep;
            const angleStep = 0.08;
            let angle = Math.random() * Math.PI * 2;
            const maxRadius = Math.max(containerWidth, containerHeight) * 2;
            const maxAttempts = 2e4;
            let attempts = 0;
            while (!placed && spiralRadius < maxRadius && attempts < maxAttempts) {
              const testCenterX = centerX + spiralRadius * Math.cos(angle);
              const testCenterY = centerY + spiralRadius * Math.sin(angle);
              let neededWidth = tagWidth;
              let neededHeight = tagHeight;
              if (Math.abs(rotation) === 90) {
                [neededWidth, neededHeight] = [neededHeight, neededWidth];
              }
              const left = testCenterX - neededWidth / 2;
              const right = testCenterX + neededWidth / 2;
              const top = testCenterY - neededHeight / 2;
              const bottom = testCenterY + neededHeight / 2;
              const margin = spacingConfig.margin;
              if (left >= margin && right <= containerWidth - margin && top >= margin && bottom <= containerHeight - margin) {
                const testRect = {
                  centerX: testCenterX,
                  centerY: testCenterY,
                  width: tagWidth,
                  height: tagHeight,
                  rotation
                };
                let hasOverlap = false;
                for (let i = 0; i < placedElements.length; i++) {
                  if (checkOverlap(testRect, placedElements[i])) {
                    hasOverlap = true;
                    break;
                  }
                }
                if (!hasOverlap) {
                  const x = testCenterX - tagWidth / 2;
                  const y = testCenterY - tagHeight / 2;
                  tag.style.left = x + "px";
                  tag.style.top = y + "px";
                  tag.style.transform = `rotate(${rotation}deg)`;
                  tag.style.transformOrigin = "center center";
                  placedElements.push(testRect);
                  placed = true;
                }
              }
              angle += angleStep;
              spiralRadius += spiralStep * (angleStep / (2 * Math.PI));
              attempts++;
            }
            if (!placed) {
              tag.remove();
            }
          }
          if (placed) {
            tag.dataset.rotation = String(rotation);
            tag.dataset.isCentered = String(isCentered);
            tag.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              renderWords(temp.word);
            });
            tag.addEventListener("touchend", (e) => {
              e.preventDefault();
              e.stopPropagation();
              renderWords(temp.word);
            });
            tag.addEventListener("mouseenter", () => {
              if (!isCentered) {
                const rot = parseInt(tag.dataset.rotation || "0");
                tag.style.transform = `rotate(${rot}deg) scale(1.1)`;
                tag.style.zIndex = "100";
              }
            });
            tag.addEventListener("mouseleave", () => {
              if (!isCentered) {
                const rot = parseInt(tag.dataset.rotation || "0");
                tag.style.transform = `rotate(${rot}deg) scale(1)`;
                tag.style.zIndex = "1";
              }
            });
            let touchScaleTimeout;
            tag.addEventListener("touchstart", (e) => {
              if (!isCentered) {
                const rot = parseInt(tag.dataset.rotation || "0");
                tag.style.transform = `rotate(${rot}deg) scale(1.1)`;
                tag.style.zIndex = "100";
                if (touchScaleTimeout) {
                  window.clearTimeout(touchScaleTimeout);
                }
              }
            });
            tag.addEventListener("touchcancel", () => {
              if (!isCentered) {
                touchScaleTimeout = window.setTimeout(() => {
                  const rot = parseInt(tag.dataset.rotation || "0");
                  tag.style.transform = `rotate(${rot}deg) scale(1)`;
                  tag.style.zIndex = "1";
                }, 100);
              }
            });
          }
        });
      };
    };
    setTimeout(() => {
      const randomWord = words[Math.floor(Math.random() * words.length)];
      renderWords(randomWord);
    }, 100);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WordCloudModal = class extends import_obsidian.Modal {
  constructor(app, plugin, editor) {
    super(app);
    this.plugin = plugin;
    this.editor = editor;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Generate Word Cloud" });
    const separator = this.plugin.settings.separator || ",";
    const separatorName = separator === "," ? "comma" : separator === "." ? "period" : separator === " " ? "space" : `"${separator}"`;
    const inputContainer = contentEl.createDiv();
    inputContainer.style.marginBottom = "20px";
    const helperText = inputContainer.createEl("p", {
      text: `Enter words separated by ${separatorName}`
    });
    helperText.style.fontSize = "0.9em";
    helperText.style.color = "var(--text-muted)";
    helperText.style.marginBottom = "8px";
    const textarea = inputContainer.createEl("textarea");
    textarea.placeholder = `Enter ${separatorName}-separated words...`;
    textarea.value = "";
    textarea.style.width = "100%";
    textarea.style.minHeight = "100px";
    textarea.style.padding = "10px";
    textarea.style.marginBottom = "10px";
    textarea.style.fontSize = "16px";
    textarea.style.boxSizing = "border-box";
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.flexWrap = "wrap";
    const previewBtn = buttonContainer.createEl("button", { text: "Preview" });
    previewBtn.style.flex = "1";
    previewBtn.style.minWidth = "80px";
    previewBtn.addEventListener("click", () => {
      const previewContainer = contentEl.querySelector(".preview-container");
      if (previewContainer) {
        previewContainer.remove();
      }
      const preview = contentEl.createDiv("preview-container");
      preview.style.marginTop = "20px";
      preview.style.border = "1px solid var(--background-modifier-border)";
      preview.style.borderRadius = "8px";
      preview.style.padding = "20px";
      this.plugin.renderWordCloud(textarea.value, preview);
    });
    const insertBtn = buttonContainer.createEl("button", { text: "Insert into Note" });
    insertBtn.style.flex = "1";
    insertBtn.style.minWidth = "80px";
    insertBtn.addEventListener("click", () => {
      if (this.editor) {
        const codeBlock = "```wordcloud\n" + textarea.value + "\n```\n";
        this.editor.replaceSelection(codeBlock);
        new import_obsidian.Notice("Word cloud inserted!");
        this.close();
      } else {
        new import_obsidian.Notice("No active editor found");
      }
    });
    const refreshBtn = buttonContainer.createEl("button", { text: "Refresh" });
    refreshBtn.style.flex = "1";
    refreshBtn.style.minWidth = "80px";
    refreshBtn.addEventListener("click", () => {
      const previewContainer = contentEl.querySelector(".preview-container");
      if (previewContainer) {
        previewContainer.empty();
        this.plugin.renderWordCloud(textarea.value, previewContainer);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var WordCloudSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Word Cloud Settings" });
    new import_obsidian.Setting(containerEl).setName("Word separator").setDesc("Character used to separate words in the cloud").addDropdown((dropdown) => dropdown.addOption(",", "Comma (,)").addOption(".", "Period (.)").addOption(" ", "Space ( )").addOption(";", "Semicolon (;)").addOption("|", "Pipe (|)").setValue(this.plugin.settings.separator).onChange(async (value) => {
      this.plugin.settings.separator = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Text casing").setDesc("Transform word casing for consistent appearance").addDropdown((dropdown) => dropdown.addOption("as-is", "As-is (keep original)").addOption("uppercase", "UPPERCASE").addOption("lowercase", "lowercase").addOption("title-case", "Title Case").setValue(this.plugin.settings.casing).onChange(async (value) => {
      this.plugin.settings.casing = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Font Size" });
    new import_obsidian.Setting(containerEl).setName("Auto font size").setDesc("Automatically adjust font sizes based on word count (recommended)").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoFontSize).onChange(async (value) => {
      this.plugin.settings.autoFontSize = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (!this.plugin.settings.autoFontSize) {
      new import_obsidian.Setting(containerEl).setName("Minimum font size").setDesc("Minimum font size in pixels").addText((text) => text.setPlaceholder("12").setValue(String(this.plugin.settings.minFontSize)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.minFontSize = num;
          await this.plugin.saveSettings();
        }
      }));
      new import_obsidian.Setting(containerEl).setName("Maximum font size").setDesc("Maximum font size in pixels").addText((text) => text.setPlaceholder("48").setValue(String(this.plugin.settings.maxFontSize)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.maxFontSize = num;
          await this.plugin.saveSettings();
        }
      }));
    } else {
      const autoInfo = containerEl.createEl("div");
      autoInfo.style.padding = "10px";
      autoInfo.style.marginBottom = "15px";
      autoInfo.style.backgroundColor = "var(--background-secondary)";
      autoInfo.style.borderRadius = "4px";
      autoInfo.style.fontSize = "0.9em";
      autoInfo.style.lineHeight = "1.6";
      autoInfo.createEl("div", { text: "\u{1F4D0} Auto sizing rules (Desktop):" }).style.fontWeight = "bold";
      autoInfo.createEl("div", { text: "\u2022 1-10 words: 20-56px (big & bold)" });
      autoInfo.createEl("div", { text: "\u2022 11-20 words: 16-40px (balanced)" });
      autoInfo.createEl("div", { text: "\u2022 21-40 words: 14-32px (compact)" });
      autoInfo.createEl("div", { text: "\u2022 41-70 words: 12-28px (dense)" });
      autoInfo.createEl("div", { text: "\u2022 70+ words: 10-22px (very dense)" });
      autoInfo.createEl("div", { text: "" });
      autoInfo.createEl("div", { text: "\u{1F4F1} On mobile, font sizes are automatically reduced by ~40% to fit more words on smaller screens." }).style.fontStyle = "italic";
    }
    containerEl.createEl("h3", { text: "Word Spacing" });
    new import_obsidian.Setting(containerEl).setName("Auto spacing").setDesc("Automatically adjust spacing based on word count (recommended)").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSpacing).onChange(async (value) => {
      this.plugin.settings.autoSpacing = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (!this.plugin.settings.autoSpacing) {
      new import_obsidian.Setting(containerEl).setName("Spacing preset").setDesc("Space between words. Change this and refresh your word cloud to see the difference.").addDropdown((dropdown) => dropdown.addOption("compact", "Compact - Very tight").addOption("normal", "Normal - Balanced").addOption("comfortable", "Comfortable - Loose").addOption("loose", "Loose - Very loose").setValue(this.plugin.settings.spacing).onChange(async (value) => {
        this.plugin.settings.spacing = value;
        await this.plugin.saveSettings();
      }));
    } else {
      const autoInfo = containerEl.createEl("div");
      autoInfo.style.padding = "10px";
      autoInfo.style.marginBottom = "15px";
      autoInfo.style.backgroundColor = "var(--background-secondary)";
      autoInfo.style.borderRadius = "4px";
      autoInfo.style.fontSize = "0.9em";
      autoInfo.style.lineHeight = "1.6";
      autoInfo.createEl("div", { text: "\u{1F4CF} Auto spacing rules (Desktop):" }).style.fontWeight = "bold";
      autoInfo.createEl("div", { text: "\u2022 1-10 words: Loose (spread out nicely)" });
      autoInfo.createEl("div", { text: "\u2022 11-20 words: Comfortable" });
      autoInfo.createEl("div", { text: "\u2022 21-40 words: Normal" });
      autoInfo.createEl("div", { text: "\u2022 40+ words: Compact (fit everything)" });
      autoInfo.createEl("div", { text: "" });
      autoInfo.createEl("div", { text: "\u{1F4F1} On mobile, spacing is automatically tighter to maximize word visibility." }).style.fontStyle = "italic";
    }
    containerEl.createEl("h3", { text: "Color Palette" });
    const colorDesc = containerEl.createEl("p", {
      text: "Colors used for words in the cloud. Click on a color to change it, or add/remove colors."
    });
    colorDesc.style.fontSize = "0.9em";
    colorDesc.style.color = "var(--text-muted)";
    colorDesc.style.marginBottom = "10px";
    const colorContainer = containerEl.createDiv();
    colorContainer.style.display = "flex";
    colorContainer.style.flexWrap = "wrap";
    colorContainer.style.gap = "10px";
    colorContainer.style.marginBottom = "15px";
    const renderColorPalette = () => {
      colorContainer.empty();
      this.plugin.settings.colorPalette.forEach((color, index) => {
        const colorItem = colorContainer.createDiv();
        colorItem.style.display = "flex";
        colorItem.style.alignItems = "center";
        colorItem.style.gap = "8px";
        colorItem.style.padding = "5px";
        colorItem.style.border = "1px solid var(--background-modifier-border)";
        colorItem.style.borderRadius = "4px";
        const colorInput = colorItem.createEl("input");
        colorInput.type = "color";
        colorInput.value = color;
        colorInput.style.width = "50px";
        colorInput.style.height = "30px";
        colorInput.style.border = "none";
        colorInput.style.cursor = "pointer";
        colorInput.addEventListener("change", async (e) => {
          const target = e.target;
          this.plugin.settings.colorPalette[index] = target.value;
          await this.plugin.saveSettings();
        });
        const colorLabel = colorItem.createEl("span");
        colorLabel.textContent = color.toUpperCase();
        colorLabel.style.fontSize = "0.9em";
        colorLabel.style.fontFamily = "monospace";
        colorLabel.style.minWidth = "70px";
        const removeBtn = colorItem.createEl("button");
        removeBtn.textContent = "\xD7";
        removeBtn.style.padding = "2px 8px";
        removeBtn.style.marginLeft = "5px";
        removeBtn.style.cursor = "pointer";
        removeBtn.setAttribute("aria-label", "Remove color");
        removeBtn.addEventListener("click", async () => {
          if (this.plugin.settings.colorPalette.length > 1) {
            this.plugin.settings.colorPalette.splice(index, 1);
            await this.plugin.saveSettings();
            renderColorPalette();
          } else {
            new import_obsidian.Notice("You must have at least one color in the palette");
          }
        });
        if (this.plugin.settings.colorPalette.length === 1) {
          removeBtn.disabled = true;
          removeBtn.style.opacity = "0.3";
        }
      });
      const addColorBtn = colorContainer.createEl("button");
      addColorBtn.textContent = "+ Add Color";
      addColorBtn.style.padding = "5px 15px";
      addColorBtn.style.cursor = "pointer";
      addColorBtn.addEventListener("click", async () => {
        const randomColor = "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0");
        this.plugin.settings.colorPalette.push(randomColor);
        await this.plugin.saveSettings();
        renderColorPalette();
      });
    };
    renderColorPalette();
    new import_obsidian.Setting(containerEl).setName("Reset color palette").setDesc("Reset colors to default palette").addButton((button) => button.setButtonText("Reset to Defaults").onClick(async () => {
      this.plugin.settings.colorPalette = [...DEFAULT_SETTINGS.colorPalette];
      await this.plugin.saveSettings();
      renderColorPalette();
      new import_obsidian.Notice("Color palette reset to defaults");
    }));
  }
};
